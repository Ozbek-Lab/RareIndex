# Generated by Django on 2026-01-26

from django.db import migrations, models
import django.db.models.deletion
import django.contrib.contenttypes.models
from django.conf import settings
import simple_history.models


def migrate_old_analysis_to_pipeline(apps, schema_editor):
    """Migrate old Analysis/AnalysisType data to Pipeline/PipelineType.

    This migration was originally written against SQLite and uses
    `sqlite_master` and `PRAGMA` statements extensively. On non-SQLite
    backends (e.g. PostgreSQL in Docker), these tables do not exist and
    the SQL would fail.

    For non-SQLite databases we skip this data-migration entirely:
    fresh PostgreSQL databases will not have the old Analysis/AnalysisType
    tables that this code is trying to clean up, so there is nothing to
    migrate.

    Order of operations (SQLite only):
    1. Update variants: Connect to individuals and clear analysis_id
    2. Rename AnalysisType → PipelineType (tables in DB)
    3. Rename Analysis → Pipeline (tables in DB)
    4. Clean up any incorrectly created M2M tables
    """
    # Skip on non-SQLite backends (e.g. PostgreSQL)
    if schema_editor.connection.vendor != 'sqlite':
        return

    with schema_editor.connection.cursor() as cursor:
        # Check table existence
        cursor.execute("""
            SELECT name FROM sqlite_master 
            WHERE type='table' AND name IN ('lab_analysis', 'lab_pipeline', 'lab_analysistype', 'lab_pipelinetype')
        """)
        existing_tables = {row[0] for row in cursor.fetchall()}
    
    old_analysis_exists = 'lab_analysis' in existing_tables
    pipeline_exists = 'lab_pipeline' in existing_tables
    old_analysistype_exists = 'lab_analysistype' in existing_tables
    pipelinetype_exists = 'lab_pipelinetype' in existing_tables
    
    # STEP 1: Update variants BEFORE renaming tables
    # For each variant with a connected Analysis: Connect it to the individual instead
    # and remove its connection to the Analysis object
    # Only do this if lab_analysis table exists (might not exist on fresh DB)
    if old_analysis_exists:
        with schema_editor.connection.cursor() as cursor:
            cursor.execute("""
                SELECT name FROM sqlite_master 
                WHERE type='table' AND name='variant_variant'
            """)
            variant_table_exists = cursor.fetchone() is not None
            
            if variant_table_exists:
                cursor.execute("PRAGMA table_info(variant_variant)")
                column_names = [row[1] for row in cursor.fetchall()]
                
                # If variant has analysis_id column (pointing to old Analysis)
                if 'analysis_id' in column_names and 'individual_id' in column_names:
                    # Update individual_id for variants that have analysis_id but missing individual_id
                    cursor.execute("""
                        UPDATE variant_variant
                        SET individual_id = (
                            SELECT lab_individual.id
                            FROM lab_analysis
                            JOIN lab_test ON lab_analysis.test_id = lab_test.id
                            JOIN lab_sample ON lab_test.sample_id = lab_sample.id
                            JOIN lab_individual ON lab_sample.individual_id = lab_individual.id
                            WHERE lab_analysis.id = variant_variant.analysis_id
                        )
                        WHERE analysis_id IS NOT NULL 
                        AND (individual_id IS NULL OR individual_id = '')
                    """)
                    
                    # Clear analysis_id since new Analysis objects don't exist yet
                    # (variants will be reconnected to new Analysis objects later)
                    cursor.execute("""
                        UPDATE variant_variant
                        SET analysis_id = NULL
                        WHERE analysis_id IS NOT NULL
                    """)
    
    # STEP 2: Convert AnalysisType → PipelineType (rename tables in database)
    if old_analysistype_exists and not pipelinetype_exists:
        with schema_editor.connection.cursor() as cursor:
            # Rename main table
            cursor.execute("ALTER TABLE lab_analysistype RENAME TO lab_pipelinetype")
            
            # Rename M2M table
            cursor.execute("""
                SELECT name FROM sqlite_master 
                WHERE type='table' AND name='lab_analysistype_parent_types'
            """)
            if cursor.fetchone():
                cursor.execute("ALTER TABLE lab_analysistype_parent_types RENAME TO lab_pipelinetype_parent_types")
            
            # Rename historical table
            cursor.execute("""
                SELECT name FROM sqlite_master 
                WHERE type='table' AND name='lab_historicalanalysistype'
            """)
            if cursor.fetchone():
                cursor.execute("ALTER TABLE lab_historicalanalysistype RENAME TO lab_historicalpipelinetype")
    
    # STEP 3: Convert Analysis → Pipeline (rename tables in database)
    if old_analysis_exists and not pipeline_exists:
        with schema_editor.connection.cursor() as cursor:
            # Rename main table
            cursor.execute("ALTER TABLE lab_analysis RENAME TO lab_pipeline")
            
            # Rename historical table
            cursor.execute("""
                SELECT name FROM sqlite_master 
                WHERE type='table' AND name='lab_historicalanalysis'
            """)
            if cursor.fetchone():
                cursor.execute("ALTER TABLE lab_historicalanalysis RENAME TO lab_historicalpipeline")
    
    # STEP 4: Clean up any leftover lab_analysistype/lab_analysis tables and indexes
    # (from previous failed migration attempts) before creating new models
    with schema_editor.connection.cursor() as cursor:
        # Always try to drop indexes and tables (IF EXISTS handles non-existence)
        # Drop all indexes for lab_analysistype (if any exist)
        cursor.execute("""
            SELECT name FROM sqlite_master 
            WHERE type='index' AND tbl_name='lab_analysistype' AND name NOT LIKE 'sqlite_autoindex%'
        """)
        for row in cursor.fetchall():
            cursor.execute(f"DROP INDEX IF EXISTS {row[0]}")
        # Drop the table (drops all indexes automatically)
        cursor.execute("DROP TABLE IF EXISTS lab_analysistype")
        
        # Drop M2M table
        cursor.execute("DROP TABLE IF EXISTS lab_analysistype_parent_types")
        
        # Drop historical table
        cursor.execute("DROP TABLE IF EXISTS lab_historicalanalysistype")
        
        # Drop all indexes for lab_analysis (if any exist)
        cursor.execute("""
            SELECT name FROM sqlite_master 
            WHERE type='index' AND tbl_name='lab_analysis' AND name NOT LIKE 'sqlite_autoindex%'
        """)
        for row in cursor.fetchall():
            cursor.execute(f"DROP INDEX IF EXISTS {row[0]}")
        # Drop the table (drops all indexes automatically)
        cursor.execute("DROP TABLE IF EXISTS lab_analysis")
        
        cursor.execute("DROP TABLE IF EXISTS lab_historicalanalysis")


def cleanup_all_leftover_indexes(apps, schema_editor):
    """Drop ALL indexes matching patterns (handles variable hash suffixes).

    Like `migrate_old_analysis_to_pipeline`, this is SQLite-specific and
    relies on the `sqlite_master` table. On PostgreSQL there is nothing
    to do here, and attempting to query `sqlite_master` will raise an
    error, preventing migrations (and therefore the container) from
    starting.
    """
    # Skip on non-SQLite backends (e.g. PostgreSQL)
    if schema_editor.connection.vendor != 'sqlite':
        return

    with schema_editor.connection.cursor() as cursor:
        # Get all indexes matching patterns (regardless of hash suffix)
        cursor.execute("""
            SELECT name FROM sqlite_master 
            WHERE type='index' 
            AND (
                name LIKE 'lab_analysistype%' 
                OR name LIKE 'lab_historicalanalysistype%'
                OR name LIKE 'lab_analysis%'
                OR name LIKE 'lab_historicalanalysis%'
            )
            AND name NOT LIKE 'sqlite_autoindex%'
        """)
        for row in cursor.fetchall():
            try:
                cursor.execute(f"DROP INDEX IF EXISTS {row[0]}")
            except Exception:
                pass  # Ignore errors if index doesn't exist


def reverse_migrate(apps, schema_editor):
    """Reverse migration - not fully reversible"""
    pass


class Migration(migrations.Migration):

    dependencies = [
        ('lab', '0006_profile_display_preferences'),
        ('contenttypes', '0002_remove_content_type_name'),
        migrations.swappable_dependency(settings.AUTH_USER_MODEL),
    ]

    operations = [
        # First, tell Django's migration state that Analysis → Pipeline and AnalysisType → PipelineType
        # This updates the migration state even if tables were already renamed
        migrations.RenameModel(
            old_name='Analysis',
            new_name='Pipeline',
        ),
        migrations.RenameModel(
            old_name='AnalysisType',
            new_name='PipelineType',
        ),
        migrations.RenameModel(
            old_name='HistoricalAnalysis',
            new_name='HistoricalPipeline',
        ),
        migrations.RenameModel(
            old_name='HistoricalAnalysisType',
            new_name='HistoricalPipelineType',
        ),
        
        # Data migration: rename old Analysis/AnalysisType tables to Pipeline/PipelineType in database
        # (if not already renamed) and update variant references
        migrations.RunPython(migrate_old_analysis_to_pipeline, reverse_migrate),
        
        # Explicitly drop any leftover indexes before creating new models
        # (handles cases where syncdb or previous attempts created them)
        # Dynamically finds and drops ALL indexes matching patterns (handles variable hash suffixes)
        migrations.RunPython(cleanup_all_leftover_indexes, migrations.RunPython.noop),
        
        # Create new AnalysisType model
        migrations.CreateModel(
            name='AnalysisType',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('name', models.CharField(max_length=255)),
                ('description', models.TextField(blank=True, null=True)),
                ('version', models.CharField(blank=True, max_length=50, null=True)),
                ('source_url', models.URLField(blank=True, help_text='URL to the analysis source code or documentation', max_length=500, null=True)),
                ('results_url', models.URLField(blank=True, help_text='URL to view analysis results', max_length=500, null=True)),
                ('created_by', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='created_analysis_types', to=settings.AUTH_USER_MODEL)),
                ('parent_types', models.ManyToManyField(blank=True, related_name='subtypes', to='lab.analysistype')),
            ],
            options={
                'ordering': ['name', '-version'],
            },
            bases=(models.Model,),
        ),
        # Update Pipeline and PipelineType Meta options and fields to match models.py
        migrations.AlterModelOptions(
            name='pipeline',
            options={'ordering': ['-id'], 'verbose_name_plural': 'pipelines'},
        ),
        migrations.AlterModelOptions(
            name='historicalpipeline',
            options={'get_latest_by': ('history_date', 'history_id'), 'ordering': ('-history_date', '-history_id'), 'verbose_name': 'historical pipeline', 'verbose_name_plural': 'historical pipelines'},
        ),
        migrations.AlterModelOptions(
            name='historicalpipelinetype',
            options={'get_latest_by': ('history_date', 'history_id'), 'ordering': ('-history_date', '-history_id'), 'verbose_name': 'historical pipeline type', 'verbose_name_plural': 'historical pipeline types'},
        ),
        migrations.AlterField(
            model_name='pipeline',
            name='created_by',
            field=models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='created_pipelines', to=settings.AUTH_USER_MODEL),
        ),
        migrations.AlterField(
            model_name='pipeline',
            name='test',
            field=models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='pipelines', to='lab.test'),
        ),
        migrations.AlterField(
            model_name='pipelinetype',
            name='created_by',
            field=models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='created_pipeline_types', to=settings.AUTH_USER_MODEL),
        ),
        migrations.AlterField(
            model_name='pipelinetype',
            name='source_url',
            field=models.URLField(blank=True, help_text='URL to the pipeline source code or documentation', max_length=500, null=True),
        ),
        migrations.AlterField(
            model_name='pipelinetype',
            name='results_url',
            field=models.URLField(blank=True, help_text='URL to view pipeline results', max_length=500, null=True),
        ),
        migrations.AlterField(
            model_name='historicalpipelinetype',
            name='source_url',
            field=models.URLField(blank=True, help_text='URL to the pipeline source code or documentation', max_length=500, null=True),
        ),
        migrations.AlterField(
            model_name='historicalpipelinetype',
            name='results_url',
            field=models.URLField(blank=True, help_text='URL to view pipeline results', max_length=500, null=True),
        ),
        # Create new Analysis model
        migrations.CreateModel(
            name='Analysis',
            fields=[
                ('id', models.BigAutoField(auto_created=True, primary_key=True, serialize=False, verbose_name='ID')),
                ('performed_date', models.DateField()),
                ('pipeline', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='analyses', to='lab.Pipeline')),
                ('performed_by', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, to=settings.AUTH_USER_MODEL)),
                ('type', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, to='lab.analysistype')),
                ('status', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, to='lab.status')),
                ('created_by', models.ForeignKey(on_delete=django.db.models.deletion.PROTECT, related_name='created_analyses', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name_plural': 'analyses',
                'ordering': ['-id'],
            },
            bases=(models.Model,),
        ),
        # Create HistoricalAnalysisType
        migrations.CreateModel(
            name='HistoricalAnalysisType',
            fields=[
                ('id', models.BigIntegerField(auto_created=True, blank=True, db_index=True, verbose_name='ID')),
                ('name', models.CharField(max_length=255)),
                ('description', models.TextField(blank=True, null=True)),
                ('version', models.CharField(blank=True, max_length=50, null=True)),
                ('source_url', models.URLField(blank=True, help_text='URL to the analysis source code or documentation', max_length=500, null=True)),
                ('results_url', models.URLField(blank=True, help_text='URL to view analysis results', max_length=500, null=True)),
                ('history_id', models.AutoField(primary_key=True, serialize=False)),
                ('history_date', models.DateTimeField(db_index=True)),
                ('history_change_reason', models.CharField(max_length=100, null=True)),
                ('history_type', models.CharField(choices=[('+', 'Created'), ('~', 'Changed'), ('-', 'Deleted')], max_length=1)),
                ('created_by', models.ForeignKey(blank=True, db_constraint=False, null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to=settings.AUTH_USER_MODEL)),
                ('history_user', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='+', to=settings.AUTH_USER_MODEL)),
            ],
            options={
                'verbose_name': 'historical analysis type',
                'verbose_name_plural': 'historical analysis types',
                'ordering': ('-history_date', '-history_id'),
                'get_latest_by': ('history_date', 'history_id'),
            },
            bases=(simple_history.models.HistoricalChanges, models.Model),
        ),
        # Create HistoricalAnalysis
        migrations.CreateModel(
            name='HistoricalAnalysis',
            fields=[
                ('id', models.BigIntegerField(auto_created=True, blank=True, db_index=True, verbose_name='ID')),
                ('performed_date', models.DateField()),
                ('history_id', models.AutoField(primary_key=True, serialize=False)),
                ('history_date', models.DateTimeField(db_index=True)),
                ('history_change_reason', models.CharField(max_length=100, null=True)),
                ('history_type', models.CharField(choices=[('+', 'Created'), ('~', 'Changed'), ('-', 'Deleted')], max_length=1)),
                ('created_by', models.ForeignKey(blank=True, db_constraint=False, null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to=settings.AUTH_USER_MODEL)),
                ('history_user', models.ForeignKey(null=True, on_delete=django.db.models.deletion.SET_NULL, related_name='+', to=settings.AUTH_USER_MODEL)),
                ('performed_by', models.ForeignKey(blank=True, db_constraint=False, null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to=settings.AUTH_USER_MODEL)),
                ('pipeline', models.ForeignKey(blank=True, db_constraint=False, null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='lab.Pipeline')),
                ('status', models.ForeignKey(blank=True, db_constraint=False, null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='lab.status')),
                ('type', models.ForeignKey(blank=True, db_constraint=False, null=True, on_delete=django.db.models.deletion.DO_NOTHING, related_name='+', to='lab.analysistype')),
            ],
            options={
                'verbose_name': 'historical analysis',
                'verbose_name_plural': 'historical analyses',
                'ordering': ('-history_date', '-history_id'),
                'get_latest_by': ('history_date', 'history_id'),
            },
            bases=(simple_history.models.HistoricalChanges, models.Model),
        ),
        # Note: Index on analysis.id is not needed as primary key already has an index
    ]
